git grep "DEBUG"
en el dir principal para ver lo que queda por limpiar en el proyecto


HANDLERS:
processReqTexto por ahi se puede usar para binario tambien,
lo unico que cambiaria es el GET, y se puede usar eloop->isText para checkear
validateReq tambien se puede reutilizar, con eloop->isText


politica de desalojo:
desalojar la clave valor menos usada, con la stat mas baja?
Prob sea la mas reciente, pero es cierto que llevar una cola para desalojar la primera
relentizaria mucho el programa

Tenemos la memoria que va a usar el programa definida en una constante en algun lado

Usar esa definicion de memoria para hacer un calculo correcto del tamaño (size) de la tabla hash

Usar una tabla hash de tamaño (Size),
resolver colisiones usando arboles.
Cada elemento de la tabla tiene un lock (Size locks)

Uso de memoria y desalojo:
Queue de punteros a los nodos en el orden en el que los guardamos
Cada vez que se accede a memoria, se mueve el puntero al principio de la lista (cambiando los punteros anterior y sig)
El elemento del final de la lista es el mas antiguo y menos accedido, por lo q es el cual eliminamos.

Usar una estructura de epoll para recuperar los msjes de tcp
--Borrar la memoria alocada a la estructura cuando un cliente se desconecte

Para el LRU:
Cuando vayamos a liberar memoria, usar trylocks cuando intentemos eliminar un nodo, y en caso de no poder, probar con el siguiente
Para evitar deadlocks.

En cuanto a los archivos:
hash_table.c y hash_table.h estan temporales para testear el server,
despues vamos a hash.c y hash.h que estan en la carpeta structures.

Parseo de text:
Casos a considerar:
Se recibe una string sin \n: ("PUT clav")
    - Se checkea que no contenga caracteres no imprimibles
    - Se checkea que no supere los 2048 caracteres
	- Se guarda en la estructura de eloop_data 
Mientras estamos leyendo:
	Llega un "\n":
		- 
	i > 2048:
		-Se guarda una bandera de einval=true
		-Se sigue leyendo hasta llegar al /n
Cuando terminamos de leer:
	Cuando unimos las strings que nos llegaron al eloop_data:
	Si resulta mas larga que 2048:
		-Respondemos con einval y desechamos la request


parametros:
-t text_socket
-b bin_socket
-m mem_limit
-np NumeroProcesadores ? o tomar el maximo de procesadores que hay disponibles. Si hay que tener buena performance capaz conviene tomar todos.


Para poder usar el ctree, tendriamos que poder definir una funcion que nos diga que un nodo es menor que otro.
Dentro de los criterios que existen esta comparar la clave o el valor, lo cual puede ser muy costoso.
Se decidio utilizar la lista enlazada como estructura que almacena los nodos, por este motivo.


Al momento de realizar un PUT, se puede crear un nodo con create_node_from_KV(char* key, int lenkey, char *value, int lenvalue),
y despues llamar a _PUT(Hashtable *ht, Node *node)

para realizar un GET o DEL, se puede crear un nodo con Node* create_node_from_K(char* key, int lenkey),
y despues llamar a _GET / _DEL (Hashtable *ht, Node *node)

Funcionalidades faltantes de la tabla hash:
-Actualizar estadisticas.
-Armas la LRU.
- funcion de EVICT (desalojo)


usar tryalloc en vez de malloc, en todos lados
hacer free de todas las cosas que llamen a tryalloc, como char** req por ejemplo
chequear que el manejo de errores sea correcto, en todos lados.(los tryalloc pueden devolver NULL, y los create_node tambien).
en el reqHandler, se podria simplificar el codigo de imrpimir las respuestas con code_str?
tipo if OK:
		write(" ok v")
	else
		write(code_str(var), strlen(code_str(var)));

Los stats funcionan de la siguiente manera:

Stats* snapshot;
int ret = snapshot_stats(ht, snapshot);
y en snapshot quedan las variables guardadas,
despues eliminar snapshot con:
destroy_stats(snapshot);


La funcion hash:
int hash_string(char *value) {
  unsigned long long int key = 0;
  for (int i = 0; value[i] != '\0'; i++) {
    key += value[i] * pow(2, (i % 10));
  }
  key = key % TABLESIZE;
  return (int) key;
}
- deberia devolver un unsigned long.
- no deberia tener el % tablesize.
- usa pow() que se podria hacer mas eficiente.
- habria que de alguna manera chequear que no sea posible que devuelva valores negativos.


la flag de printable se podria pasar como parametro cuando creas el nodo.

Si no tenemos suficiente memoria como para alojar una nueva conexion (tryalloc(epoll_data) da NULL), entonces por 
politica de mejor esfuerzo, en vez de hacer un quit, podriamos dejar pasar esa conexion.



