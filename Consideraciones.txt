politica de desalojo:
desalojar la clave valor menos usada, con la stat mas baja?
Prob sea la mas reciente, pero es cierto que llevar una cola para desalojar la primera
relentizaria mucho el programa

Tenemos la memoria que va a usar el programa definida en una constante en algun lado

Usar esa definicion de memoria para hacer un calculo correcto del tamaño (size) de la tabla hash

Usar una tabla hash de tamaño (Size),
resolver colisiones usando arboles.
Cada elemento de la tabla tiene un lock (Size locks)

Uso de memoria y desalojo:
Queue de punteros a los nodos en el orden en el que los guardamos
Cada vez que se accede a memoria, se mueve el puntero al principio de la lista (cambiando los punteros anterior y sig)
El elemento del final de la lista es el mas antiguo y menos accedido, por lo q es el cual eliminamos.

Usar una estructura de epoll para recuperar los msjes de tcp
--Borrar la memoria alocada a la estructura cuando un cliente se desconecte

Para el LRU:
Cuando vayamos a liberar memoria, usar trylocks cuando intentemos eliminar un nodo, y en caso de no poder, probar con el siguiente
Para evitar deadlocks.

En cuanto a los archivos:
hash_table.c y hash_table.h estan temporales para testear el server,
despues vamos a hash.c y hash.h que estan en la carpeta structures.



parametros:
-t text_socket
-b bin_socket
-m mem_limit
-np NumeroProcesadores ? o tomar el maximo de procesadores que hay disponibles. Si hay que tener buena performance capaz conviene tomar todos.


Para poder usar el ctree, tendriamos que poder definir una funcion que nos diga que un nodo es menor que otro.
Dentro de los criterios que existen esta comparar la clave o el valor, lo cual puede ser muy costoso.
Se decidio utilizar la lista enlazada como estructura que almacena los nodos, por este motivo.



Al momento de realizar un PUT, se puede crear un nodo con create_node_from_KV(char* key, int lenkey, char *value, int lenvalue),
y despues llamar a _PUT(Hashtable *ht, Node *node)

para realizar un GET o DEL, se puede crear un nodo con Node* create_node_from_K(char* key, int lenkey),
y despues llamar a _GET / _DEL (Hashtable *ht, Node *node)

Funcionalidades faltantes de la tabla hash:
-Actualizar estadisticas.
-Armas la LRU.
- funcion de EVICT (desalojo)



