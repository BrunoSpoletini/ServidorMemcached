git grep "DEBUG"
en el dir principal para ver lo que queda por limpiar en el proyecto


HANDLERS:
processReqTexto por ahi se puede usar para binario tambien,
lo unico que cambiaria es el GET, y se puede usar eloop->isText para checkear
validateReq tambien se puede reutilizar, con eloop->isText


politica de desalojo:
desalojar la clave valor menos usada, con la stat mas baja?
Prob sea la mas reciente, pero es cierto que llevar una cola para desalojar la primera
relentizaria mucho el programa

Tenemos la memoria que va a usar el programa definida en una constante en algun lado

Usar esa definicion de memoria para hacer un calculo correcto del tamaño (size) de la tabla hash

Usar una tabla hash de tamaño (Size),
resolver colisiones usando arboles.
Cada elemento de la tabla tiene un lock (Size locks)

Uso de memoria y desalojo:
Queue de punteros a los nodos en el orden en el que los guardamos
Cada vez que se accede a memoria, se mueve el puntero al principio de la lista (cambiando los punteros anterior y sig)
El elemento del final de la lista es el mas antiguo y menos accedido, por lo q es el cual eliminamos.

Usar una estructura de epoll para recuperar los msjes de tcp
--Borrar la memoria alocada a la estructura cuando un cliente se desconecte

Para el LRU:
Cuando vayamos a liberar memoria, usar trylocks cuando intentemos eliminar un nodo, y en caso de no poder, probar con el siguiente
Para evitar deadlocks.

En cuanto a los archivos:
hash_table.c y hash_table.h estan temporales para testear el server,
despues vamos a hash.c y hash.h que estan en la carpeta structures.

Parseo de text:
Casos a considerar:
Se recibe una string sin \n: ("PUT clav")
    - Se checkea que no contenga caracteres no imprimibles
    - Se checkea que no supere los 2048 caracteres
	- Se guarda en la estructura de eloop_data 
Mientras estamos leyendo:
	Llega un "\n":
		- 
	i > 2048:
		-Se guarda una bandera de einval=true
		-Se sigue leyendo hasta llegar al /n
Cuando terminamos de leer:
	Cuando unimos las strings que nos llegaron al eloop_data:
	Si resulta mas larga que 2048:
		-Respondemos con einval y desechamos la request


parametros:
-t text_socket
-b bin_socket
-m mem_limit
-np NumeroProcesadores ? o tomar el maximo de procesadores que hay disponibles. Si hay que tener buena performance capaz conviene tomar todos.


Para poder usar el ctree, tendriamos que poder definir una funcion que nos diga que un nodo es menor que otro.
Dentro de los criterios que existen esta comparar la clave o el valor, lo cual puede ser muy costoso.
Se decidio utilizar la lista enlazada como estructura que almacena los nodos, por este motivo.


Al momento de realizar un PUT, se puede crear un nodo con create_node_from_KV(char* key, int lenkey, char *value, int lenvalue),
y despues llamar a _PUT(Hashtable *ht, Node *node)

para realizar un GET o DEL, se puede crear un nodo con Node* create_node_from_K(char* key, int lenkey),
y despues llamar a _GET / _DEL (Hashtable *ht, Node *node)

Funcionalidades faltantes de la tabla hash:
-Actualizar estadisticas.
-Armas la LRU.
- funcion de EVICT (desalojo)



